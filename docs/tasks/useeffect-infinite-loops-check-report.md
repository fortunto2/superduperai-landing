# Отчет: Проверка бесконечных циклов в useEffect

## Обзор

Проведена проверка кодовой базы на наличие потенциальных бесконечных циклов в хуках useEffect. В результате сканирования обнаружено использование useEffect в следующих файлах:

1. `src/components/landing/navbar.tsx`
2. `src/components/landing/hero.tsx`

Всего обнаружено **2 использования useEffect** в компонентах.

## Детальный анализ

### 1. Компонент Navbar (`src/components/landing/navbar.tsx`)

```jsx
useEffect(() => {
  const handleScroll = () => {
    setIsScrolled(window.scrollY > 10);
  };

  window.addEventListener("scroll", handleScroll);
  return () => {
    window.removeEventListener("scroll", handleScroll);
  };
}, []);
```

**Оценка**: ✅ Безопасно

**Комментарии**:
- Пустой массив зависимостей `[]` гарантирует, что эффект выполнится только один раз при монтировании компонента
- Корректная очистка с помощью функции return, которая удаляет event listener
- Функция `handleScroll` определена внутри эффекта, что устраняет необходимость включать её в зависимости
- Нет прямой мутации состояния внутри эффекта, только в обработчике события

### 2. Компонент Hero (`src/components/landing/hero.tsx`)

```jsx
useEffect(() => {
  const timer = setInterval(() => {
    setCurrentSlide((prev) => (prev + 1) % slides.length);
  }, 5000);
  
  return () => clearInterval(timer);
}, [slides.length]);
```

**Оценка**: ✅ Безопасно, но есть замечание

**Комментарии**:
- Зависимость `[slides.length]` означает, что эффект перезапустится при изменении длины массива слайдов
- Внутри используется функциональное обновление состояния `setCurrentSlide((prev) => ...)`, что правильно с точки зрения независимости от текущего значения состояния
- Корректная очистка с помощью `clearInterval` предотвращает утечки памяти
- **Замечание**: `slides` определен как константа внутри компонента, поэтому его длина не должна меняться между рендерами. Можно использовать пустой массив зависимостей `[]` для оптимизации

## Выводы и рекомендации

В результате проверки **не обнаружено потенциальных бесконечных циклов** в используемых хуках useEffect. Код написан с соблюдением рекомендаций React по использованию useEffect:

1. Все хуки имеют корректные массивы зависимостей
2. Все эффекты с подписками имеют функции очистки
3. Используются функциональные обновления состояния

### Рекомендации для поддержания кода:

1. В компоненте Hero можно оптимизировать useEffect, заменив `[slides.length]` на `[]`, так как slides - константа:

```jsx
useEffect(() => {
  const timer = setInterval(() => {
    setCurrentSlide((prev) => (prev + 1) % slides.length);
  }, 5000);
  
  return () => clearInterval(timer);
}, []); // Оптимизация: пустой массив зависимостей
```

2. При добавлении новых useEffect в проект следовать тем же принципам:
   - Указывать корректный массив зависимостей
   - Использовать функции очистки для подписок и таймеров
   - Предпочитать функциональные обновления состояния

3. Добавить ESLint плагин для React Hooks (react-hooks/exhaustive-deps) для автоматической проверки зависимостей

## Заключение

Текущий код не содержит проблем с бесконечными циклами в useEffect, однако рекомендуется продолжать следовать лучшим практикам при написании новых компонентов и добавить инструменты автоматической проверки в процесс разработки. 